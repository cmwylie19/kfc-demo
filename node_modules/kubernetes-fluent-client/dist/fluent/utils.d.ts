import { RequestInit } from "node-fetch";
import { URL } from "url";
import { Dispatcher } from "undici";
import { GenericClass } from "../types.js";
import { ApplyCfg, Filters, K8sConfigPromise, FetchMethods } from "./shared-types.js";
/**
 * Get the headers for a request
 *
 * @param token - the token from @kubernetes/client-node
 * @returns the headers for undici
 */
export declare function getHeaders(token?: string | null): Promise<Record<string, string>>;
/**
 * Get the agent for a request
 *
 * @param opts - the request options from node-fetch
 * @returns the agent for undici
 */
export declare function getHTTPSAgent(opts: RequestInit): Dispatcher | undefined;
/**
 * Read the serviceAccount Token
 *
 * @returns token or null
 */
export declare function getToken(): Promise<string | null>;
/**
 * Generate a path to a Kubernetes resource
 *
 * @param serverUrl - the URL of the Kubernetes API server
 * @param model - the model to use for the API
 * @param filters - (optional) filter overrides, can also be chained
 * @param excludeName - (optional) exclude the name from the path
 * @returns the path to the resource
 */
export declare function pathBuilder<T extends GenericClass>(serverUrl: string, model: T, filters: Filters, excludeName?: boolean): URL;
/**
 * Sets up the kubeconfig and https agent for a request
 *
 * A few notes:
 * - The kubeconfig is loaded from the default location, and can check for in-cluster config
 * - We have to create an agent to handle the TLS connection (for the custom CA + mTLS in some cases)
 * - The K8s lib uses request instead of node-fetch today so the object is slightly different
 *
 * @param method - the HTTP method to use
 * @returns the fetch options and server URL
 */
export declare function k8sCfg(method: FetchMethods): K8sConfigPromise;
/**
 * Prepares and mutates the request options and URL for Kubernetes PATCH or APPLY operations.
 *
 * This function modifies the request's HTTP method, headers, and URL based on the operation type.
 * It handles the following:
 *
 * - `PATCH_STATUS`: Converts the method to `PATCH`, appends `/status` to the path, sets merge patch headers,
 *   and rewrites the payload to contain only the `status` field.
 * - `PATCH`: Sets the content type to `application/json-patch+json`.
 * - `APPLY`: Converts the method to `PATCH`, sets server-side apply headers, and updates the query string
 *   with field manager and force options.
 *
 * @template K
 * @param methodPayload - The original method and payload. May be mutated if `PATCH_STATUS` is used.
 * @param opts - The request options.
 * @param opts.method - The HTTP method (e.g. `PATCH`, `APPLY`, or `PATCH_STATUS`).
 * @param opts.headers - The headers to be updated with the correct content type.
 * @param url - The URL to mutate with subresource path or query parameters.
 * @param applyCfg - Server-side apply options, such as `force`.
 */
export declare function prepareRequestOptions<K>(methodPayload: MethodPayload<K>, opts: {
    method?: string;
    headers?: Record<string, string>;
}, url: URL, applyCfg: ApplyCfg): void;
export type MethodPayload<K> = {
    method: FetchMethods;
    payload?: K | unknown;
    subResourceConfig?: SubResourceConfig;
};
export type SubResourceConfig = {
    ProxyConfig?: {
        port: string;
    };
    ScaleConfig?: {
        replicas: number;
    };
};
/**
 * Execute a request against the Kubernetes API server.
 *
 * @param model - the model to use for the API
 * @param filters - (optional) filter overrides, can also be chained
 * @param methodPayload - method and payload for the request
 * @param applyCfg - (optional) configuration for the apply method
 *
 * @returns the parsed JSON response
 */
export declare function k8sExec<T extends GenericClass, K>(model: T, filters: Filters, methodPayload: MethodPayload<K>, applyCfg?: ApplyCfg): Promise<K>;
/**
 * Handles subresource configuration for specific Kubernetes resources.
 *
 * @param kind - The kind of the Kubernetes resource (e.g., "Pod", "Service", "Node").
 * @param urlPath - The base URL path to append the subresource to.
 * @param subResourceConfig - The subresource configuration object.
 * @returns The modified URL path with the subresource appended, or the urlPath if no subresource is configured.
 * @throws Error if the kind is not supported for proxy configuration.
 */
export declare function handleSubResourceConfig(kind: string, urlPath: string, subResourceConfig?: SubResourceConfig): string;
//# sourceMappingURL=utils.d.ts.map